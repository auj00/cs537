void *mmap(void addr[.length], size_t length, int prot, int flags,
                  int fd, off_t offset);




objective:
fd <-> virtual_addr

/*****************************************
anonymous mapping:
 *****************************************/
request address to be mapped to fd;
address passed is virtual, which needs to be mapped to a physical page.

for(i<n){

char* Kalloc():
track which pages are free to be allocated
returns  1 pg.

mappages(proc_pddir,virtual_addr,1,V2P(pa),rd_wr); //1size in pg
store this in this pagetable

}

/*****************************************
 file backed mapping:
 *****************************************/
fileread(struct file, char addr, int n(length))


look up read and write syscalls to convert fd to file struct.
addr : virtual_addr
n = 1 


/********************************************************************************************************************************************************************/

int munmap(void addr[.length], size_t length);

length not availiable in uwunamp so store the length during mapp.

keep track of wchi pages are dirty.
0 out the page table entries

K free.pa = 



walkpgdir-> gets the pte address 
P2V(pte) to get the virtual addr
free that address


/*****************************************
 page fault
 *****************************************/

 case T_PGFLT: // T_PGFLT = 14
 int va = lcr2();
if page fault addr is part of a mapping: // lazy allocation
// handle it
map the address
else:
cprintf("Segmentation Fault\n");
// kill the process


/*****************************************
    copy on write
 *****************************************/

make all pages read only,
if any page tries to write, seg fault, handle it .